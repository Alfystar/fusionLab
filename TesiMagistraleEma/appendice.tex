\chapter*{Appendice A\\ Arduino Code}\label{ArduinoCode}
\addcontentsline{toc}{chapter}{Appendice A - Codice Arduino}
\setcounter{chapter}{\thechapter + 1}

\section{Set-up Registri}
\subsection{Tic Timer}

\begin{lstlisting}[style=cppStyle,caption={Tic Timer},label=lst:ticTimer] 
	void periodicTask(int time) { 		// time in micro secondi
		// PWM pin Disable, motalita CTC(pt1)
		TCCR2A = (0x0 << COM2A0) | (0x0 << COM2B0) | (0x2 << WGM20);
		// CTC(pt2), Prescalere 256
		TCCR2B = (0 << WGM22) | (0x6 << CS20);                       
		// T_cklock * Twant / Prescaler = valore Registro
		OCR2A = (int)(16UL * time / 256);
		TIMSK2 = (1 << OCIE2A); // attivo solo l'interrupt di OC2A
	}
\end{lstlisting}
Questa funzione imposta il TIMER2 in modalità Fast PWM, ovvero che si resetta quando arriva al conteggio finale, e calcola il valore da mettere nel registro affinchè il conteggio sia il più vicino possibile a tempo desiderato

\subsection{Frequenza PWM}

\begin{lstlisting}[style=cppStyle,caption={Frequenza PWM},label=lst:pwmFreq] 
enum pwmFreq: char {
	hz30, hz120, hz490, hz4k, hz30k
};

void setMotFreq(pwmFreq freq) {
	// TCCR0B is for Timer 0
	#define myTimer TCCR0B
	switch (freq) {
		// set timer 3 divisor to  1024 for PWM frequency of    30.64 Hz
		case hz30:
			myTimer = (myTimer & B11111000) | B00000101;
		break;
		case hz120:
		// set timer 3 divisor to   256 for PWM frequency of   122.55 Hz
			myTimer = (myTimer & B11111000) | B00000100;
		break;
		case hz490:
		// set timer 3 divisor to    64 for PWM frequency of   490.20 Hz
			myTimer = (myTimer & B11111000) | B00000011;
		break;
		case hz4k:
		// set timer 3 divisor to     8 for PWM frequency of  3921.16 Hz
			myTimer = (myTimer & B11111000) | B00000010;
		break;
		case hz30k:
		// set timer 3 divisor to     1 for PWM frequency of 31372.55 Hz
			myTimer = (myTimer & B11111000) | B00000001;
		break;
		default:
			setMotFreq(hz4k);
		break;
	}
	#undef myTimer
}
\end{lstlisting}
Mediante questa funzione si modifica il valore del Prescaler per il TIMER 0, modificando la velocità di conteggio si ottiene un PWM con una periodo, e quindi frequenza, che varia.

\subsubsection{Offset Calculation}

\begin{lstlisting}[style=cppStyle,caption={Macro per calcolo Offset},label=lst:offsetCalc] 
#define offsetCalc(pin,n)            \
({                                   \
	long read = 0;                     \
	for (int i = 0; i < 1 << n; i++) { \
		read += analogRead(pin);         \
		delay(1);                        \
	}                                  \
	read = read >> 5;                  \
	read;                              \
})
\end{lstlisting}
\noindent
La macro misura con una distanza temporale di 1 ms $2^n$-volte, la misura del Pin, e successivamente ne fa la media eseguendo un revers shift, questa tecnica di divisione semplicemente minimizza il tempo di calcolo, poiché ogni revers shift equivale a una divisione per 2, e si ha l'effetto di dividere per $\frac{read}{2^n}$ in $O(n)$ con un operazione per il processore molto semplice.

\newpage
\section{Generatore di Segnale}

Per generare i segnali di controllo in Feed-Forward usati nel sistema, sono stati usati 2 diversi livelli di programmazione.\\
Un primo livello segnali di base, definiti su tutto $\mathbb{R}$, e usabili a piacere, e dei segnali compositi e periodici da mandare durante l'esperimento.
Tutti i segnali sono pensati per andare da -100\% <-> 100\%, è compito dell'attuazione
eliminare le deadzone e traslare il controllo al valore più opportuno

\subsection{Segnali Base}

\subsubsection{Rampa}
\begin{lstlisting}[style=cppStyle,caption={Rampa Saturata},label=lst:rampa] 
int ramp(uint64_t t, int vStart, uint64_t tStart, int vEnd, uint64_t tEnd) {
	// Saturazione
	if (t < tStart)
		return vStart;
	else if (t > tEnd)
		return vEnd;
	// Retta
	unsigned int dt = t - tStart;
	return vStart + int((vEnd - vStart) / float(tEnd - tStart) * dt);
}
\end{lstlisting}
La rampa è descritta come una retta nell'intervallo di interesse, saturata prima e dopo il tempo desiderato\\
$ RampaSat(t) =
	\left \{ \begin{array}{l c}
		v_{start} + \frac{v_{end}-v_{start}}{t_{end}-t_{start}} * (t - t_{start}) & \forall t \in [t_{start},t_{end}] \\
		v_{start}                                                                 & t<t_{start}                       \\
		v_{end}                                                                   & t>t_{start}
	\end{array}
	\right.
$

\newpage
\subsection{Segnali Composti}

\subsubsection{Onda Triangloare}
\begin{lstlisting}[style=cppStyle,caption={Onda Triangolare Periodica},label=lst:ondaTriangloare] 
int triangleSignal(uint64_t t, int msQuartPeriod) {
	static uint64_t startTic = 0;
	int dTic = t - startTic;
	int pwm = 0;
	if (dTic < ticConvert(msQuartPeriod))
		pwm = ramp(dTic, 0, 0, 100, ticConvert(msQuartPeriod));
	else if (dTic < (ticConvert(msQuartPeriod) * 3))
		pwm = ramp(dTic, 100, ticConvert(msQuartPeriod), -100, ticConvert(msQuartPeriod) * 3);
	else if (dTic < (ticConvert(msQuartPeriod) * 4))
		pwm = ramp(dTic, -100, ticConvert(msQuartPeriod) * 3, 0, ticConvert(msQuartPeriod) * 4);
	else {
		pwm = 0;
		startTic = t;
	}
	return pwm;
}
\end{lstlisting}

\subsubsection{Onda Trapezoidale}
\begin{lstlisting}[style=cppStyle,caption={Onda Trapezoidale Periodica},label=lst:ondaTrapezoidale] 
int rapidShot(uint64_t t) {
	static uint64_t startTic = 0;
	int pwmRapidShot;
	long dTic = t - startTic;
	if (dTic > t4) {
		startTic = t;
		pwmRapidShot = 0;
		dTic = t - startTic;
	}
	
	if (dTic <= t1) {
		pwmRapidShot = ramp(dTic, 0, 0, 100, t1);
	} else if (dTic <= t2) {
		pwmRapidShot = 100;
	} else if (dTic <= t3) {
		// falling ramp
		pwmRapidShot = ramp(dTic, 100, t2, 0, t3);
	} else if (dTic <= t4) {
		pwmRapidShot = 0;
	}	
	return pwmRapidShot;
}
\end{lstlisting}

\newpage

\section{Codici Controllore}

\subsubsection{Setup dell'esperimento}
\begin{lstlisting}[style=cppStyle,caption={Loop di Controllo},label=lst:controlSetup] 
void setup() {
	mpSerial.begin(2000000);
	
	memset(&pRead, 0, sizeof(pRead));
	memset(&pWrite, 0, sizeof(pWrite));
	
	// Motori
	setMotFreq(hz30k);
	mot = new DCdriver(enPwm, inA, inB);
	
	// Mean find
	pMean.V2_mean = offsetCalc(V2, 5);
	pMean.Isense_mean = offsetCalc(Isense, 5);
	pMean.dt = dtExperiment;
	
	// Ctrl Reference
	Ctrl.setNewRef(tic, 0);
	
	// ################# Start Experiment #################
	mpSerial.bufClear();
	// Start Delay
	memset(&pWrite, 0, sizeof(pWrite));
	pWrite.type = sampleType;
	delay(1000);
	periodicTask(pMean.dt);
	sei();
}
\end{lstlisting}

\subsubsection{Loop di Controllo}
\begin{lstlisting}[style=cppStyle,caption={Loop di Controllo},label=lst:controlLoop] 
volatile u32 oldTic = tic;
int readData;
int pwm;
void loop() {
	mpSerial.updateState();
	do {
		readData = mpSerial.getData_try(&pRead);
		if (readData >= 0) {
			serialExe(&pRead);
		}
	} while (tic == oldTic);
	
	pWrite.read.V2_read = analogRead(V2);
	pWrite.read.Isense_read = analogRead(Isense);
	pwm = mot->drive_motor(Ctrl.ctrlStep(oldTic, pWrite.read.V2_read - pMean.V2_mean));
	pWrite.read.pwm = pwm;
	pWrite.read.err = Ctrl.lastErr;
	
	oldTic++; // Suppose no over time
	mpSerial.packSend(&pWrite, sizeof(pWrite.type) + sizeof(pWrite.read));
}
\end{lstlisting}

\chapter*{Appendice B\\ EMP Code}\label{EMPCode}
\addcontentsline{toc}{chapter}{Appendice B - Codice EMP}
\setcounter{chapter}{\thechapter + 1}

\section{Pacchetti in EMP}
\subsection{Definizione di 2 Pacchetti}
Ecco di seguito un esempio di definizione asimmetrica per pacchetti da un Device (Linux), verso un altro (Arduino), e viceversa:\\
\begin{lstlisting}[style=cppStyle,caption={esempio di definizione Pacchetto in EMP},label=lst:EMPpackDef] 
#include <stdint.h>	// To be sure for the footPrint in any platform
struct _packLinux2Ard {
	int16_t num;
	char buf[20];
} __attribute__((packed));
typedef struct _packLinux2Ard packLinux2Ard;

struct _packArd2Linux {
	int16_t num;
	char buf[10];
} __attribute__((packed));
typedef struct _packArd2Linux packArd2Linux;
\end{lstlisting}
\noindent
Come si può osservare, il sistema non necessita di alcun formato particolare per la definizione dei pacchetti, essi sono delle semplici strutture in C, con l'attributo \verb|__attribute__((packed))| per eliminare Padding e ottimizzare la memoria.
Come è possibile notare, le regole non vietano la definizione di 2 pacchetti diversi e asimmetrici.
\newpage

\subsection{Pacchetti Multipli}
Per definire un pacchetto di pacchetti, il metodo migliore è creare un \verb|enum| per numerare univocamente il tipo (nell'esempio \verb|uint8_t| ma può essere reso maggiore all'occorrenza), e una \verb|union| con tutti i tipi in fila.\\
Il pacchetto di interesse per \citefield{EMP}{title} è \verb|dataSend|, ed è responsabilità dell'utente della libreria riempire correttamente i campi.\\
\begin{lstlisting}[style=cppStyle,caption={definizione Pacchetti Multipli},label=lst:EMPmultiplePack] 
//DataType1 ,DataType2, DataType3 typedef above;
enum packTypeSend : uint8_t{
	DataType1code,
	DataType2code,
	DataType3code,
};
typedef union{
	DataType1 t1;
	DataType2 t2;
	DataType3 t3;
}  __attribute__((packed)) dataSendUnion;

typedef struct{
	packTypeSend type;
	dataSendUnion pack;
}  __attribute__((packed)) dataSend;
\end{lstlisting}
\noindent
Per ottimizzare l'invio al minimo strettamente necessario si può quindi usare la variante nel metodo di \verb|packSend(...)|, in cui viene specificata la dimensione:

\begin{lstlisting}[style=cppStyle,caption={definizione Pacchetti Multipli},label=lst:EMPsendOptimize] 
//...
dataSend.type = DataType2code;
dataSend.pack.t2 = /*{data}*/ // fill correctly dataSend
//...    
MP->packSend(&data, sizeof(packTypeSend) + sizeof(DataType2));
//...

\end{lstlisting}
\chapter*{Appendice C\\ Matlab Post Elaborazione}\label{MatlabCode}
\addcontentsline{toc}{chapter}{Appendice C - Matlab Post Elaboration}
\setcounter{chapter}{\thechapter + 1}